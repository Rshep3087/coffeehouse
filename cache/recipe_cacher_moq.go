// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package cache

import (
	"context"
	"github.com/rshep3087/coffeehouse/postgres"
	"sync"
)

// Ensure, that RecipeCacherMock does implement RecipeCacher.
// If this is not the case, regenerate this file with moq.
var _ RecipeCacher = &RecipeCacherMock{}

// RecipeCacherMock is a mock implementation of RecipeCacher.
//
//	func TestSomethingThatUsesRecipeCacher(t *testing.T) {
//
//		// make and configure a mocked RecipeCacher
//		mockedRecipeCacher := &RecipeCacherMock{
//			GetRecipeFunc: func(ctx context.Context, id int64) (*postgres.Recipe, error) {
//				panic("mock out the GetRecipe method")
//			},
//			SetRecipeFunc: func(ctx context.Context, id int64, recipe *postgres.Recipe) error {
//				panic("mock out the SetRecipe method")
//			},
//		}
//
//		// use mockedRecipeCacher in code that requires RecipeCacher
//		// and then make assertions.
//
//	}
type RecipeCacherMock struct {
	// GetRecipeFunc mocks the GetRecipe method.
	GetRecipeFunc func(ctx context.Context, id int64) (*postgres.Recipe, error)

	// SetRecipeFunc mocks the SetRecipe method.
	SetRecipeFunc func(ctx context.Context, id int64, recipe *postgres.Recipe) error

	// calls tracks calls to the methods.
	calls struct {
		// GetRecipe holds details about calls to the GetRecipe method.
		GetRecipe []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// SetRecipe holds details about calls to the SetRecipe method.
		SetRecipe []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
			// Recipe is the recipe argument value.
			Recipe *postgres.Recipe
		}
	}
	lockGetRecipe sync.RWMutex
	lockSetRecipe sync.RWMutex
}

// GetRecipe calls GetRecipeFunc.
func (mock *RecipeCacherMock) GetRecipe(ctx context.Context, id int64) (*postgres.Recipe, error) {
	if mock.GetRecipeFunc == nil {
		panic("RecipeCacherMock.GetRecipeFunc: method is nil but RecipeCacher.GetRecipe was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetRecipe.Lock()
	mock.calls.GetRecipe = append(mock.calls.GetRecipe, callInfo)
	mock.lockGetRecipe.Unlock()
	return mock.GetRecipeFunc(ctx, id)
}

// GetRecipeCalls gets all the calls that were made to GetRecipe.
// Check the length with:
//
//	len(mockedRecipeCacher.GetRecipeCalls())
func (mock *RecipeCacherMock) GetRecipeCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockGetRecipe.RLock()
	calls = mock.calls.GetRecipe
	mock.lockGetRecipe.RUnlock()
	return calls
}

// SetRecipe calls SetRecipeFunc.
func (mock *RecipeCacherMock) SetRecipe(ctx context.Context, id int64, recipe *postgres.Recipe) error {
	if mock.SetRecipeFunc == nil {
		panic("RecipeCacherMock.SetRecipeFunc: method is nil but RecipeCacher.SetRecipe was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		ID     int64
		Recipe *postgres.Recipe
	}{
		Ctx:    ctx,
		ID:     id,
		Recipe: recipe,
	}
	mock.lockSetRecipe.Lock()
	mock.calls.SetRecipe = append(mock.calls.SetRecipe, callInfo)
	mock.lockSetRecipe.Unlock()
	return mock.SetRecipeFunc(ctx, id, recipe)
}

// SetRecipeCalls gets all the calls that were made to SetRecipe.
// Check the length with:
//
//	len(mockedRecipeCacher.SetRecipeCalls())
func (mock *RecipeCacherMock) SetRecipeCalls() []struct {
	Ctx    context.Context
	ID     int64
	Recipe *postgres.Recipe
} {
	var calls []struct {
		Ctx    context.Context
		ID     int64
		Recipe *postgres.Recipe
	}
	mock.lockSetRecipe.RLock()
	calls = mock.calls.SetRecipe
	mock.lockSetRecipe.RUnlock()
	return calls
}
